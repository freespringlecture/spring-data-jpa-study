# 3. ORM 패러다임 불일치
## 밀도(Granularity) 문제
| 객체                                                         | 릴레이션                                  |
| ------------------------------------------------------------ | ----------------------------------------- |
| 다양한 크기의 객체를 만들 수 있음<br />커스텀한 타입 만들기 쉬움 | 테이블<br />기본 데이터 타입 (UDT는 비추) |

## 서브타입(Subtype) 문제
| 객체                              | 릴레이션                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| 상속 구조 만들기 쉬움<br />다형성 | 테이블 상속이라는게 없음<br />상속 기능을 구현했다 하더라도 표준 기술이 아님<br />다형적인 관계를 표현할 방법이 없음 |

## 식별성(Identity) 문제
| 객체                                                        | 릴레이션           |
| ----------------------------------------------------------- | ------------------ |
| 레퍼런스 동일성 (==)<br />인스턴스 동일성 (equals() 메소드) | 주키 (primary key) |

## 관계(Association) 문제
| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 객체 레퍼런스로 관계 표현<br />근본적으로 '방향'이 존재한다<br />다대다 관계를 가질 수 있음 | 외래키(foreign key)로 관계 표현<br />'방향'이라는 의미가 없음<br />그냥 join으로 아무거나 묶을 수 있음<br />태생적으로 다대다 관계를 못만들고, 조인 테이블 또는 링크 테이블을 사용해서 두개의 1대다 관계로 풀어야 함 |

## 데이터 네비게이션(Navitation)의 문제
| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 레퍼런스를 이용해서 다른 객체로 이동 가능<br />콜렉션을 순회할 수도 있음 | 하지만 그런 방식은 릴레이션에서 데이터를 조회하는데 있어서 매우 비효율적이다<br />데이터베이스에 요청을 적게 할 수록 성능이 좋다<br />따라서 join을 쓴다<br />하지만, 너무 많이 한 번에 가져오려고 해도 문제다<br />그렇다고 lazy loading을 하자니 그것도 문제다 (n+1 select) |